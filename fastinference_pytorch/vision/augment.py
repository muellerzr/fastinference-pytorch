# AUTOGENERATED! DO NOT EDIT! File to edit: 01b_vision.augment.ipynb (unless otherwise specified).

__all__ = ['CropPad', 'Resize', 'RandomResizedCrop', 'RatioResize', 'to_device', 'apply', 'noop', 'Normalize',
           'IntToFloatTensor']

# Cell
from torch import stack, zeros_like as t0, ones_like as t1
from torch.distributions.bernoulli import Bernoulli
from torch import Tensor, tensor
from PIL import Image

# Cell
from fastcore.dispatch import patch
from fastcore.utils import mk_class, is_listy
from fastcore.dispatch import Tuple, retain_type
import operator, math

# Cell
from torchvision.transforms.functional import pad as tvpad

# Cell
mk_class('PadMode', **{o:o.lower() for o in ['Zeros', 'Border', 'Reflection']},
         doc="All possible padding mode as attributes to get tab-completion and typo-proofing")

@patch
def _do_crop_pad(x:Image.Image, sz, tl, orig_sz,
                 pad_mode=PadMode.Zeros, resize_mode=Image.BILINEAR, resize_to=None):
    if any(tl.ge(0)):
        # At least one dim is inside the image, so needs to be cropped
        c = tl.max(0)
        x = x.crop((*c, *c.add(sz).min(orig_sz)))
    if any(tl.lt(0)):
        # At least one dim is outside the image, so needs to be padded
        p = (-tl).max(0)
        f = (sz-orig_sz-p).max(0)
        x = tvpad(x, (*p, *f), padding_mode=_pad_modes[pad_mode])
    if resize_to is not None: x = x.resize(resize_to, resize_mode)
    return x

@patch
def crop_pad(x:Image.Image, sz, tl=None, orig_sz=None, pad_mode=PadMode.Zeros, resize_mode=Image.BILINEAR, resize_to=None):
    if isinstance(sz,int): sz = (sz,sz)
    orig_sz = Tuple(_get_sz(x) if orig_sz is None else orig_sz)
    sz,tl = Tuple(sz),Tuple(((_get_sz(x)-sz)//2) if tl is None else tl)
    return x._do_crop_pad(sz, tl, orig_sz=orig_sz, pad_mode=pad_mode, resize_mode=resize_mode, resize_to=resize_to)

# Cell
def _process_sz(size):
    if isinstance(size,int): size=(size,size)
    return Tuple(size[1],size[0])

def _get_sz(x):
    if isinstance(x, tuple): x = x[0]
    if not isinstance(x, Tensor): return Tuple(x.size)
    return im.size

# Cell
class CropPad():
    "Center crop or pad an image to `size`"
    order=0
    def __init__(self, size, pad_mode=PadMode.Zeros):
        self.size,self.pad_mode = _process_sz(size),pad_mode
    def __call__(self, x):
        orig_sz = _get_sz(x)
        tl = (orig_sz-self.size)//2
        return x.crop_pad(self.size,tl,orig_sz=orig_sz,pad_mode=self.pad_mode)

# Cell
mk_class('ResizeMethod', **{o:o.lower() for o in ['Squish', 'Crop', 'Pad']},
         doc="All possible resize method as attributes to get tab-completion and typo-proofing")

# Cell
class Resize():
    order = 1
    def __init__(self, size, method=ResizeMethod.Crop, pad_mode=PadMode.Reflection,
                resample=Image.BILINEAR):
        self.size,self.pad_mode,self.method = _process_sz(size),pad_mode,method
        self.mode = resample

    def __call__(self, x):
        orig_sz = _get_sz(x)
        if self.method==ResizeMethod.Squish:
            return x.crop_pad(orig_sz, Tuple(0,0), orig_sz=orig_sz, pad_mode=self.pad_mode,
                             resize_method=self.resample, resize_to=self.size)
        w,h = orig_sz
        op = (operator.lt,operator.gt)[self.method==ResizeMethod.Pad]
        m = w/self.size[0] if op(w/self.size[0],h/self.size[1]) else h/self.size[1]
        cp_sz = (int(m*self.size[0]),int(m*self.size[1]))
        tl = Tuple(int(.5*(w-cp_sz[0])), int(.5*(h-cp_sz[1])))
        return x.crop_pad(cp_sz, tl, orig_sz=orig_sz, pad_mode=self.pad_mode,
                         resize_mode=self.mode, resize_to=self.size)

# Cell
class RandomResizedCrop():
    order = 1
    def __init__(self, size, min_scale=0.08, ratio=(3/4,4/3), resample=Image.BILINEAR,
                val_xtra=0.14):
        size = _process_sz(size)
        self.size,self.min_scale,self.ratio,self.val_xtra = size,min_scale,ratio,val_xtra
        self.mode = resample

    def __call__(self, x):
        w,h = self.orig_sz = _get_sz(x)
        xtra = math.ceil(max(*self.size[:2])*self.val_xtra/8)*8
        final_size = (self.size[0]+xtra, self.size[1]+xtra)
        tl = (0,0)
        res = x.crop_pad(self.orig_sz, tl, orig_sz = self.orig_sz,
                        resize_mode=self.mode, resize_to=final_size)
        if final_size != self.size: res = res.crop_pad(self.size)
        return res

# Cell
class RatioResize():
    order = 1
    def __init__(self, max_sz, resample=Image.BILINEAR):
        self.max_sz,self.resample = max_sz, resample

    def __call__(self, x):
        w,h = _get_sz(x)
        if w >= h: nw,nh = self.max_sz, h*self.max_sz/w
        else:      nw,nh = w *self.max_sz/h,self.max_sz
        return Resize(size=(int(nh),int(nw)),resample=self.resample)(x)

# Cell
def to_device(b, device='cpu'):
    "Recursively put `b` on `device`."
    def _inner(o): return o.to(device, non_blocking=True) if isinstance(o,Tensor) else o.to_device(device) if hasattr(o, "to_device") else o
    return apply(_inner, b)

# Cell
def apply(func, x, *args, **kwargs):
    "Apply `func` recursively to `x`, passing on args"
    if is_listy(x): return type(x)([apply(func, o, *args, **kwargs) for o in x])
    if isinstance(x,dict):  return {k: apply(func, v, *args, **kwargs) for k,v in x.items()}
    res = func(x, *args, **kwargs)
    return res if x is None else retain_type(res, x)

# Cell
def noop(x=None, *args,**kwargs):
    "Do nothing"
    return x

# Cell
class Normalize():
    order=99
    def __init__(self, mean=None, std=None, axes=(0,2,3)):
        self.mean,self.std,self.axes = mean,std,axes
    def encode(self, x:Tensor): return (x-self.mean)/self.std
    def decode(self, x:Tensor):
        f = to_device(x,'cpu') if x.device.type=='cpu' else noop
        return (x*f(self.std) + f(self.mean))

# Cell
class IntToFloatTensor():
    order = 10
    def __init__(self, div=255., div_mask=1):
        self.div = div
    def encodes(self, o:Tensor): return o.float().div_(self.div)
    def decodes(self, o:Tensor): return ((o.clamp(0.,1.)*self.div).long()) if self.div else o